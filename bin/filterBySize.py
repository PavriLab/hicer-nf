#!/usr/bin/env python

import argparse as ap
import pysam as ps
import numpy as np
import logging
import os
import re

logging.basicConfig(
    format='%(asctime)s - %(message)s',
    level=logging.INFO
)
parser = ap.ArgumentParser()
parser.add_argument(
    '-i', '--inputFile',
    help = 'SAM file as generated by the HICUP mapper'
)
parser.add_argument(
    '--minDistance',
    type = int,
    default = 500,
    help = 'minimum mapping distance a readpair is allowed to have'
)
parser.add_argument(
    '-o', '--outputFile',
    help = 'SAM file to write the filtered reads to'
)
args = parser.parse_args()

inputSam = ps.AlignmentFile(args.inputFile, 'r')
samheader = inputSam.header.as_dict()
samheader['PG'].append({'ID': 'filterBySize.py', 'VN': '1'})
# sizeDistribution = {i: 0 for i in range(20, 1501, 10)}
ditagSizes = []
total = 0
valid = 0
cis_l_10 = 0
cis_g_10 = 0
trans = 0
invalid = 0
sameInternal = 0

invalidre = re.compile('^.+\t\d+\t\S+\t\d+\t\d+\t\S+\t.+\t\d+\t\d+\t[ATCGN]+\t.+$')
with ps.AlignmentFile(args.outputFile, 'w', header = samheader) as outputSam:
    while True:
        try:
            read1 = inputSam.__next__()
            read2 = inputSam.__next__()
        except StopIteration:
            break

        total += 1
        if not (invalidre.fullmatch(read1.to_string()) and invalidre.fullmatch(read2.to_string())):
            invalid += 1
            continue

        if read1.reference_name == read2.reference_name:
            read1pos = read1.reference_start if not read1.is_reverse else read1.reference_end
            read2pos = read2.reference_start if not read2.is_reverse else read2.reference_end
            ditagSize = abs(read1pos - read2pos)
            if ditagSize < args.minDistance:
                sameInternal += 1
                continue

            elif ditagSize < 10000:
                cis_l_10 += 1

            else:
                cis_g_10 += 1

            ditagSizes.append(ditagSize)

        else:
            trans += 1

        valid += 1
        outputSam.write(read1)
        outputSam.write(read2)

inputSam.close()

outdir = os.path.dirname(args.outputFile)
prefix = os.path.join(outdir, args.inputFile.split('.')[0])
header = '\t'.join(
    [
        'File', 'Total_pairs', 'Valid_pairs', 'Cis_<10kbp',
        'Cis_>10kbp', 'Trans', 'Invalid_pairs', 'Same_circularised',
        'Same_dangling_ends', 'Same_internal', 'Re-ligation',
        'Contiguous_sequence', 'Wrong_size'
    ]
)

with open(prefix + '.size_filter_summary.txt', 'w') as summaryfile:
    summaryfile.write(header + '\n')
    summaryfile.write(args.inputFile)
    for count in [total, valid, cis_l_10, cis_g_10, trans, invalid, 0, 0, sameInternal, 0, 0, 0]:
        summaryfile.write('\t' + str(count))

bins = np.linspace(
    20, 1510, 150,
    dtype = int
)

hist, _ = np.histogramm(
    ditagSizes,
    bins
)

sizeDistribution = {k: v for k, v in zip(bins[:-1], hist)}
with open(prefix + '.ditag_size_distribution', 'w') as sizedistributionfile:
    for k, v in sizeDistribution.items():
        sizedistributionfile.write('\t'.join([str(k), str(v)]) + '\n')
